import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class DNSHeader 
{
    // There are specific details related to these at ietf.org
    int ID = -1;
    int FLAGS = -1;
    // Docs say these are unsigned
    int QDCOUNT = -1;
    int ANCOUNT = -1;
    int NSCOUNT = -1;
    int ARCOUNT = -1;

    /*  read the header from an input stream (we'll use a ByteArrayInputStream
     *  but we will only use the basic read methods of input stream to read 1 byte,
     *  or to fill in a byte array, so we'll be generic)
     */
    public static DNSHeader DecodeHeader(InputStream inputStream)
    {
        DNSHeader dnsHeader = new DNSHeader();
        try
        {
            byte[] header = new byte[12];
            inputStream.read(header);
            

            dnsHeader.ID = ((header[0] & 0xFF) << 8) | (header[1] & 0xFF);
            dnsHeader.FLAGS = ((header[2] & 0xFF) << 8) | (header[3] & 0xFF);
            dnsHeader.QDCOUNT = ((header[4] & 0xFF) << 8) | (header[5] & 0xFF);
            dnsHeader.ANCOUNT = ((header[6] & 0xFF) << 8) | (header[7] & 0xFF);
            dnsHeader.NSCOUNT = ((header[8] & 0xFF) << 8) | (header[9] & 0xFF);
            dnsHeader.ARCOUNT = ((header[10] & 0xFF) << 8) | (header[11] & 0xFF);

            return dnsHeader;
        }
        catch (IOException e)
        {
            System.err.println("An error occurred while Decoding Header: " + e.getMessage());
            return new DNSHeader();
        }
    }

    /*  This will create the header for the response. It will copy some fields
     *  from the request, and it could use the response message being built to
     *  find out about the number of answers for the response.
     */
    public static DNSHeader BuildHeaderForResponse(DNSMessage request, DNSMessage response)
    {
        DNSHeader responseHeader = new DNSHeader();

        responseHeader.ID = request.dnsHeader.ID;

        responseHeader.FLAGS = 0x8180;

        responseHeader.QDCOUNT = request.dnsHeader.QDCOUNT;

        responseHeader.ANCOUNT = (response.answers != null) ? response.answers.length : 0;

        responseHeader.NSCOUNT = (response.authorityRecords != null) ? response.authorityRecords.length : 0;

        responseHeader.ANCOUNT = (response.additionalRecords != null) ? response.additionalRecords.length : 0;

        return responseHeader;
    }

    /*  Encode the header to bytes to be sent back to the client. The OutputStream interface
     *  has methods to write a single byte or an array of bytes.
     */
    public void WriteBytes(OutputStream outputStream) throws IOException
    {
        outputStream.write((ID >> 8) & 0xFF);
        outputStream.write(ID & 0xFF);

        outputStream.write((FLAGS >> 8) & 0xFF);
        outputStream.write(FLAGS & 0xFF);

        outputStream.write((QDCOUNT >> 8) & 0xFF);
        outputStream.write((QDCOUNT & 0xFF));

        outputStream.write((ANCOUNT >> 8) & 0xFF);
        outputStream.write(ANCOUNT & 0xFF);

        outputStream.write((NSCOUNT >> 8) & 0xFF);
        outputStream.write(NSCOUNT & 0xFF);

        outputStream.write((ARCOUNT >> 8) & 0xFF);
        outputStream.write(ARCOUNT & 0xFF);
    }

    /*  Return a human readable string version of a header object. A reasonable implementation can
     *  be autogenerated by your IDE.
     */
    // public String ToString()
    // {
    //     return "";
    // }

    public static String ByteToBits(byte b)
    {
        return String.format("%8s", Integer.toBinaryString(b & 0xFF)).replace(' ', '0');
    }

}
